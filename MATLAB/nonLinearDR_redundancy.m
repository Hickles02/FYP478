%% Non-Linear Data Reconciliation
% This main function loads the true data generated by simulating the model of
% the binary distillation column. It then artificially corrupts the true
% data (using measureReal) and performs non-linear data reconciliation on the corrupted
% 'measurements', for both AVM & SVM. Lastly, it evaluates the
% effectiveness of non-linear DR and the effect of reducing the amount of
% measurements.  

%% Initialise
clear
clc

%% Load data
load('true_data', 'MM', 'X', 'tSol', 'true_data', 'v', 'p', 'u')

%% Measurements with Variance
% The function measureReal artificially corrupts the true data
variance = 0.05;   
a        = 3;
upperBound = [Inf(7,1); ones(6,1)];
lowerBound = zeros(13,1);
[measured_data, time] = measureReal(MM, X, v, u, p, tSol, variance);

% Pre-allocation
Xhat = zeros(13,1001);
XB   = zeros(a,1001);

%% Observability analysis
for i = 1:a
    % Set Up Matrices
    v = i-1; X0 = zeros(13,1);
    [Y, index] = measurements_Y(v, measured_data);
    W = varianceMatrix(length(index), variance);

    for j = 1:length(time)
        % Weighted objective function given current measurements Y(:,i)

        J = @(x) (Y(:,j) - x(index))'*W*(Y(:,j) - x(index));

        % Non-linear constraints f(x) = 0. See the bottom of the script
        % Find the non-linear estimates. Use the measurements as initial guess
        % See the help file for fmincon to understand the different required input arguments.
        Xhat(:,j) = fmincon(J, X0,[],[],[],[],lowerBound, upperBound, @nonLinearConstraints);
        X0(index) = Y(:,j);  
    end

    XB(i,:) = Xhat(9,:);

end

%% Error Metrics
% Mean Absolute Percentage Error
mapeM    = mean(100*abs((true_data.XB(:,100:end) - measured_data.XB(:,100:end))./true_data.XB(:,100:end)));
mape_avm = mean(100*abs((true_data.XB(:,100:end) - XB(1,100:end))./true_data.XB(:,100:end)));

% Residuals
resM    = true_data.XB - measured_data.XB;
res_avm = true_data.XB - XB(1,:);

% Probability distributuions
[fm, xim]     = ksdensity(resM(:,100:end));
[favm, xiavm] = ksdensity(res_avm(:,100:end));

% Preallocate
mape_svm = zeros(a-1,1);
res_svm = zeros(a-1,1001);
fsvm = zeros(a-1,100); xisvm = zeros(a-1,100);
for i = 1:a-1
    mape_svm(i) = mean(100*abs((true_data.XB(:,100:end) - XB(i+1,100:end))./true_data.XB(:,100:end)));
    res_svm(i,:) = true_data.XB - XB(i+1,:);
    [fsvm(i,:), xisvm(i,:)] = ksdensity(res_svm(i,100:end));
end

%% Display results
% Choose type of display
% Histogram                >> disp = 1
% Probability distribution >> disp = 2
disp = 1;

if disp == 1
    subplot(a,1,1)
    plot(xim, fm, 'y', xiavm, favm, 'k')
    title("Probability distribution - All Variables Measured")
    xlabel("Residual Value"); ylabel("Probability")
    legend("Measurement with MAPE = "+num2str(mapeM)+"%","Non-linear DR with MAPE = "+num2str(mape_avm)+"%")
    for i = 1:a-1
        subplot(a,1,i+1)
        plot(xim, fm, 'y', xisvm(i,:), fsvm(i,:), 'k')
        title("Probability distribution - No. = "+num2str(i))
        xlabel("Residual Value"); ylabel("Probability")
        legend("Measurement with MAPE = "+num2str(mapeM)+"%","Non-linear DR with MAPE = "+num2str(mape_svm(i))+"%")
    end 
else
    subplot(a,1,1)
    histogram(resM,50,'FaceAlpha',0.1)
    hold on
    histogram(res_avm,50,'FaceAlpha',1)
    hold off
    title("Histogram - All Variables Measured")
    xlabel("Residual Value"); ylabel("Frequency")
    legend("Measurement with MAPE = "+num2str(mapeM)+"%","Non-linear DR with MAPE = "+num2str(mape_avm)+"%")
    for i = 1:a-1
    subplot(a,1,i+1)
        histogram(resM,50,'FaceAlpha',0.1)
        hold on
        histogram(res_svm(i,:),50,'FaceAlpha',1)
        hold off
        title("Histogram - No Unmeasured = "+num2str(i))
        xlabel("Residual Value"); ylabel("Frequency")
        legend("Measurement with MAPE = "+num2str(mapeM)+"%","Non-linear DR with MAPE = "+num2str(mape_svm(i))+"%")
    end
end

% Display MAPE values in Table
NumberUnmeasuredVariables = ["M";"0";"1";"2"];
MAPE = [mapeM; mape_avm; mape_svm];
table(NumberUnmeasuredVariables, MAPE)

%% Function
function [g, f] = nonLinearConstraints(x)
g = []; % No inequality constraints
f = [x(7) - x(3) - x(2);...
     x(1) - x(2) - x(5);...
     x(6) - x(3) - x(4);...
     x(7)*x(13) - x(3)*x(10) - x(2)*x(9);...
     x(1)*x(8)  - x(2)*x(9)  - x(5)*x(11);...
     x(6)*x(12) - x(3)*x(10) - x(4)*x(10)];
end

%% Function
function [Y, index] = measurements_Y(v, measured_data)
    if v == 0 % All variables measured
        Y = [measured_data.L1; measured_data.LB; measured_data.LD; measured_data.LR;...
             measured_data.V0; measured_data.V4; measured_data.LF; measured_data.X1;...
             measured_data.XB; measured_data.XD; measured_data.Y0; measured_data.Y4;...
             measured_data.XF];
        index = (1:13); 
         
    elseif v == 1 % Remove >> L1 & X1 
        Y = [measured_data.LB; measured_data.LD; measured_data.LR;...
             measured_data.V0; measured_data.V4; measured_data.LF;...
             measured_data.XB; measured_data.XD; measured_data.Y0; measured_data.Y4;...
             measured_data.XF]; 
        index = [2:7,9:13]; 
         
    elseif v == 2 % Remove >> L1 & X1 - V4 & Y4
        Y = [measured_data.LB; measured_data.LD; measured_data.LR;...
             measured_data.V0; measured_data.LF;...
             measured_data.XB; measured_data.XD; measured_data.Y0;...
             measured_data.XF]; 
        index = [2:5,7,9:11,13];  
    end
end



