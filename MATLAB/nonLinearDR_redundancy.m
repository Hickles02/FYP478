%% Submission status
% Submitted for review - TM Louw

%% Non-Linear Data Reconciliation
% This main function loads the true data generated by the model of
% the binary distillation column. It then performs non-linear data reconciliation on the corrupted
% 'measurements', for both AVM & SVM. Lastly, it evaluates the
% effectiveness of non-linear DR and the effect of reducing the amount of
% measurements.  

% Key:
% AVM - All Variables Measured 
% SVM - Some Variables Measured
% MAPE - Mean Absolute Percentage Error

%% Initialise
clear
clc

%% Load data
load('true_data', 'measured_dataFlow', 'measured_dataMole', 'MM', 'X', 'tSol', 'true_data', 'v', 'u', 'p', 'variance', 'time')

%% Specifications & bounds
a          = 3;                       % Amout of loop iterations               
upperBound = [Inf(7,1); ones(6,1)];   % Upper bounds - flowrates can technically be infinite whilst fractions can be a maximum of 1
lowerBound = zeros(13,1);             % Lower bounds - flowrates and fractions can't be lower than zero

% Pre-allocation
Xhat = zeros(13,1001);
XB   = zeros(a,1001);

%% Observability analysis
for i = 1:a
    % Set Up Matrices
    v = i-1;            % Function specification (used in measurements_Y to specify measured variables) 
    X0 = zeros(13,1);   % Initial guesses for each loop
    [Y, index, W] = measurements_Y(v, measured_dataFlow, measured_dataMole, variance); % Generates measurement & variance matrix structures

    for j = 1:length(time)
        % Weighted objective function given current measurements Y(:,i)

        J = @(x) (Y(:,j) - x(index))'*W*(Y(:,j) - x(index));

        % Non-linear constraints f(x) = 0. See the bottom of the script
        % Find the non-linear estimates. Use the measurements as initial guess
        % See the help file for fmincon to understand the different required input arguments.
        Xhat(:,j) = fmincon(J, X0,[],[],[],[],lowerBound, upperBound, @nonLinearConstraints);  % Reconciled values for each variable
        X0(index) = Y(:,j);                                                                    % New guesses
    end

    XB(i,:) = Xhat(9,:);  % XB reconciled values for each loop (each level of redundancy)

end

%% Error Metrics
% Mean Absolute Percentage Error
mapeM    = mean(100*abs((true_data.XB(:,100:end) - measured_dataMole.XB(:,100:end))./true_data.XB(:,100:end)));
mape_avm = mean(100*abs((true_data.XB(:,100:end) - XB(1,100:end))./true_data.XB(:,100:end)));

% Residuals
resM    = true_data.XB - measured_dataMole.XB;
res_avm = true_data.XB - XB(1,:);

% Probability distributuions
[fm, xim]     = ksdensity(resM(:,100:end));
[favm, xiavm] = ksdensity(res_avm(:,100:end));

% Preallocate
mape_svm = zeros(a-1,1);
res_svm = zeros(a-1,1001);
fsvm = zeros(a-1,100); xisvm = zeros(a-1,100);
for i = 1:a-1
    mape_svm(i) = mean(100*abs((true_data.XB(:,100:end) - XB(i+1,100:end))./true_data.XB(:,100:end)));
    res_svm(i,:) = true_data.XB - XB(i+1,:);
    [fsvm(i,:), xisvm(i,:)] = ksdensity(res_svm(i,100:end));
end

%% Display results
% Choose type of display
% Histogram                >> disp = 1
% Probability distribution >> disp = 2
disp = 2;

% Plot results - Line graph
% Figure 5.3.1
if disp == 1
    subplot(a,1,1)
    plot(time(100:end,:), true_data.XB(:,100:end), 'co', time(100:end,:), measured_dataMole.XB(:,100:end), 'y', time(100:end,:), XB(:,100:end), 'k')
    title("All Variables Measured")
    xlabel('Time (s)'); ylabel('XB');
    legend('Model', "Measurement with MAPE = "+num2str(mapeM)+"%", "Data Reconciliation with MAPE = "+num2str(mape_avm)+"%", 'Location', 'best')

    for i = 1:a-1
        subplot(a,1,i+1)
        plot(time(100:end,:), true_data.XB(:,100:end), 'co', time(100:end,:), measured_dataMole.XB(:,100:end), 'y', time(100:end,:), XB(:,100:end), 'k')
        title("Some Variables Measured: No. Unmeasured = "+num2str(i*2))
        xlabel('Time (s)'); ylabel('XB');
        legend('Model', "Measurement with MAPE = "+num2str(mapeM)+"%", "Data Reconciliation with MAPE = "+num2str(mape_svm(i,1))+"%", 'Location', 'best')
    end
    sgtitle("Measurements vs the reconciled values")

% Plot results
% Figure 5.3.2
elseif disp == 2
    subplot(a,1,1)
    plot(xim, fm, 'y', xiavm, favm, 'k')
    title("Probability distribution - All Variables Measured")
    xlabel("Residual Value"); ylabel("Probability")
    xlim([-0.15 0.15]);
    legend("Measurement with MAPE = "+num2str(mapeM)+"%","Non-linear DR with MAPE = "+num2str(mape_avm)+"%")
    for i = 1:a-1
        subplot(a,1,i+1)
        plot(xim, fm, 'y', xisvm(i,:), fsvm(i,:), 'k')
        title("Probability distribution - No. = "+num2str(i))
        xlabel("Residual Value"); ylabel("Probability");
        xlim([-0.15 0.15]);
        legend("Measurement with MAPE = "+num2str(mapeM)+"%","Non-linear DR with MAPE = "+num2str(mape_svm(i))+"%")
    end 
else
    subplot(a,1,1)
    histogram(resM,50,'FaceAlpha',0.1)
    hold on
    histogram(res_avm,50,'FaceAlpha',1)
    hold off
    title("Histogram - All Variables Measured")
    xlabel("Residual Value"); ylabel("Frequency")
    legend("Measurement with MAPE = "+num2str(mapeM)+"%","Non-linear DR with MAPE = "+num2str(mape_avm)+"%")
    for i = 1:a-1
    subplot(a,1,i+1)
        histogram(resM,50,'FaceAlpha',0.1)
        hold on
        histogram(res_svm(i,:),50,'FaceAlpha',1)
        hold off
        title("Histogram - No Unmeasured = "+num2str(i))
        xlabel("Residual Value"); ylabel("Frequency")
        legend("Measurement with MAPE = "+num2str(mapeM)+"%","Non-linear DR with MAPE = "+num2str(mape_svm(i))+"%")
    end
end

% Display MAPE values in Table
% Table 5.3.1
NumberUnmeasuredVariables = ["M";"0";"1";"2"];
MAPE = [mapeM; mape_avm; mape_svm];
table(NumberUnmeasuredVariables, MAPE)

%% Function
function [g, f] = nonLinearConstraints(x)
g = []; % No inequality constraints
% Mass balances
% x(1) = L1; x(2) = LB; x(3) = LD; x(4) = LR; x(5) = V0; x(6) = V4; 
% x(7) = LF; x(8) = X1; x(9) = XB; x(10) = XD; x(11) = Y0; x(12) = Y4;
% x(13) = XF
f = [x(7) - x(3) - x(2);...
     x(1) - x(2) - x(5);...
     x(6) - x(3) - x(4);...
     x(7)*x(13) - x(3)*x(10) - x(2)*x(9);...
     x(1)*x(8)  - x(2)*x(9)  - x(5)*x(11);...
     x(6)*x(12) - x(3)*x(10) - x(4)*x(10)];
end

%% Function
function [Y, index, W] = measurements_Y(v, measured_dataFlow, measured_dataMole, variance)
    if v == 0 % All variables measured
        Y = [measured_dataFlow.L1; measured_dataFlow.LB; measured_dataFlow.LD; measured_dataFlow.LR;...
             measured_dataFlow.V0; measured_dataFlow.V4; measured_dataFlow.LF; measured_dataMole.X1;...
             measured_dataMole.XB; measured_dataMole.XD; measured_dataMole.Y0; measured_dataMole.Y4;...
             measured_dataMole.XF];
        index = (1:13); 
        W = diag([ones(7,1)*variance.^2; ones(6,1)*(variance.^2)/10]);
         
    elseif v == 1 % Remove >> L1 & X1 
        Y = [measured_dataFlow.LB; measured_dataFlow.LD; measured_dataFlow.LR;...
             measured_dataFlow.V0; measured_dataFlow.V4; measured_dataFlow.LF;...
             measured_dataMole.XB; measured_dataMole.XD; measured_dataMole.Y0; measured_dataMole.Y4;...
             measured_dataMole.XF];
        index = [2:7,9:13];
        W = diag([ones(6,1)*variance.^2; ones(5,1)*(variance.^2)/10]);
         
    elseif v == 2 % Remove >> L1 & X1 - V4 & Y4
        Y = [measured_dataFlow.LB; measured_dataFlow.LD; measured_dataFlow.LR;...
             measured_dataFlow.V0; measured_dataFlow.LF;...
             measured_dataMole.XB; measured_dataMole.XD; measured_dataMole.Y0;...
             measured_dataMole.XF];
        index = [2:5,7,9:11,13];
        W = diag([ones(5,1)*variance.^2; ones(4,1)*(variance.^2)/10]);
    end
end



